from flask import Flask, render_template, request, redirect, url_for
import pickle
import os
import pandas as pd
from scipy.cluster.hierarchy import fcluster

app = Flask(__name__)

# Paths for the files generated by train_model.py
MODEL_DIR = "model"
LINKAGE_MATRIX_PATH = os.path.join(MODEL_DIR, "linkage_matrix.pkl")
ORIGINAL_DATA_PATH = os.path.join(MODEL_DIR, "original_data.csv")

# Load the linkage matrix and original data once when the app starts
try:
    with open(LINKAGE_MATRIX_PATH, "rb") as f:
        linked = pickle.load(f)
    df = pd.read_csv(ORIGINAL_DATA_PATH)
    print("Successfully loaded linkage matrix and original data.")
except (FileNotFoundError, IOError) as e:
    print(f"Error loading model files: {e}")
    linked = None
    df = None

@app.route("/", methods=["GET"])
def index():
    """
    Renders the main page with the dendrogram and the cluster selection form.
    """
    # If the model files failed to load, display an error
    if linked is None or df is None:
        return "Error: Model files not found. Please run 'train_model.py' first.", 500
    
    return render_template("index.html")

@app.route("/result", methods=["POST"])
def result():
    """
    Processes the user's input, performs clustering, and renders the result page.
    """
    if linked is None or df is None:
        return "Error: Model files not found. Please run 'train_model.py' first.", 500

    try:
        num_clusters = int(request.form["num_clusters"])
    except (ValueError, KeyError):
        return redirect(url_for('index')) # Redirect to home if input is invalid
    
    # Use fcluster to assign cluster labels based on the chosen number of clusters
    cluster_labels = fcluster(linked, num_clusters, criterion='maxclust')

    # Create a new DataFrame with the cluster assignments and relevant data
    result_df = df.copy()
    result_df['Cluster'] = cluster_labels
    result_df = result_df.sort_values(by='Cluster')

    # Calculate and format the cluster summary statistics
    cluster_summary = result_df.groupby('Cluster').agg(
        Count=('Country', 'size'),
        Avg_GDP=('GDP', 'mean'),
        Avg_Literacy_Rate=('Literacy_Rate', 'mean'),
        Avg_Life_Expectancy=('Life_Expectancy', 'mean')
    ).round(2).reset_index()

    # Pass data to the result template
    return render_template(
        "result.html",
        num_clusters=num_clusters,
        cluster_data=result_df[['Country', 'Cluster']].to_dict('records'),
        cluster_summary=cluster_summary.to_dict('records')
    )

if __name__ == "__main__":
    app.run(debug=True)
